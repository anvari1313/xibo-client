# coding: utf-8

"""
    Xibo API

    Xibo CMS API  # noqa: E501

    OpenAPI spec version: 1.8.0
    Contact: info@xibo.org.uk
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ScheduleApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def schedule_add(self, event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs):  # noqa: E501
        """Add Schedule Event  # noqa: E501

        Add a new scheduled event for a Campaign/Layout to be shown on a Display Group/Display.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_add(event_type_id, display_order, is_priority, display_group_ids, from_dt, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_type_id: The Event Type Id to use for this Event. 1=Campaign, 2=Command, 3=Overlay (required)
        :param int display_order: The display order for this event.  (required)
        :param int is_priority: An integer indicating the priority of this event. Normal events have a priority of 0. (required)
        :param list[int] display_group_ids: The Display Group IDs for this event. Display specific Group IDs should be used to schedule on single displays. (required)
        :param datetime from_dt: The from date for this event. (required)
        :param int campaign_id: The Campaign ID to use for this Event. If a Layout is needed then the Campaign specific ID for that Layout should be used.
        :param int command_id: The Command ID to use for this Event.
        :param int day_part_id: The Day Part for this event. Overrides supported are 0(custom) and 1(always). Defaulted to 0.
        :param int sync_timezone: Should this schedule be synced to the resulting Display timezone?
        :param datetime to_dt: The to date for this event.
        :param str recurrence_type: The type of recurrence to apply to this event.
        :param int recurrence_detail: The interval for the recurrence.
        :param datetime recurrence_range: The end date for this events recurrence.
        :param str recurrence_repeats_on: The days of the week that this event repeats - weekly only
        :return: Schedule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.schedule_add_with_http_info(event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_add_with_http_info(event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs)  # noqa: E501
            return data

    def schedule_add_with_http_info(self, event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs):  # noqa: E501
        """Add Schedule Event  # noqa: E501

        Add a new scheduled event for a Campaign/Layout to be shown on a Display Group/Display.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_add_with_http_info(event_type_id, display_order, is_priority, display_group_ids, from_dt, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_type_id: The Event Type Id to use for this Event. 1=Campaign, 2=Command, 3=Overlay (required)
        :param int display_order: The display order for this event.  (required)
        :param int is_priority: An integer indicating the priority of this event. Normal events have a priority of 0. (required)
        :param list[int] display_group_ids: The Display Group IDs for this event. Display specific Group IDs should be used to schedule on single displays. (required)
        :param datetime from_dt: The from date for this event. (required)
        :param int campaign_id: The Campaign ID to use for this Event. If a Layout is needed then the Campaign specific ID for that Layout should be used.
        :param int command_id: The Command ID to use for this Event.
        :param int day_part_id: The Day Part for this event. Overrides supported are 0(custom) and 1(always). Defaulted to 0.
        :param int sync_timezone: Should this schedule be synced to the resulting Display timezone?
        :param datetime to_dt: The to date for this event.
        :param str recurrence_type: The type of recurrence to apply to this event.
        :param int recurrence_detail: The interval for the recurrence.
        :param datetime recurrence_range: The end date for this events recurrence.
        :param str recurrence_repeats_on: The days of the week that this event repeats - weekly only
        :return: Schedule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_type_id', 'display_order', 'is_priority', 'display_group_ids', 'from_dt', 'campaign_id', 'command_id', 'day_part_id', 'sync_timezone', 'to_dt', 'recurrence_type', 'recurrence_detail', 'recurrence_range', 'recurrence_repeats_on']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_type_id' is set
        if ('event_type_id' not in params or
                params['event_type_id'] is None):
            raise ValueError("Missing the required parameter `event_type_id` when calling `schedule_add`")  # noqa: E501
        # verify the required parameter 'display_order' is set
        if ('display_order' not in params or
                params['display_order'] is None):
            raise ValueError("Missing the required parameter `display_order` when calling `schedule_add`")  # noqa: E501
        # verify the required parameter 'is_priority' is set
        if ('is_priority' not in params or
                params['is_priority'] is None):
            raise ValueError("Missing the required parameter `is_priority` when calling `schedule_add`")  # noqa: E501
        # verify the required parameter 'display_group_ids' is set
        if ('display_group_ids' not in params or
                params['display_group_ids'] is None):
            raise ValueError("Missing the required parameter `display_group_ids` when calling `schedule_add`")  # noqa: E501
        # verify the required parameter 'from_dt' is set
        if ('from_dt' not in params or
                params['from_dt'] is None):
            raise ValueError("Missing the required parameter `from_dt` when calling `schedule_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'event_type_id' in params:
            form_params.append(('eventTypeId', params['event_type_id']))  # noqa: E501
        if 'campaign_id' in params:
            form_params.append(('campaignId', params['campaign_id']))  # noqa: E501
        if 'command_id' in params:
            form_params.append(('commandId', params['command_id']))  # noqa: E501
        if 'display_order' in params:
            form_params.append(('displayOrder', params['display_order']))  # noqa: E501
        if 'is_priority' in params:
            form_params.append(('isPriority', params['is_priority']))  # noqa: E501
        if 'display_group_ids' in params:
            form_params.append(('displayGroupIds', params['display_group_ids']))  # noqa: E501
            collection_formats['displayGroupIds'] = 'csv'  # noqa: E501
        if 'day_part_id' in params:
            form_params.append(('dayPartId', params['day_part_id']))  # noqa: E501
        if 'sync_timezone' in params:
            form_params.append(('syncTimezone', params['sync_timezone']))  # noqa: E501
        if 'from_dt' in params:
            form_params.append(('fromDt', params['from_dt']))  # noqa: E501
        if 'to_dt' in params:
            form_params.append(('toDt', params['to_dt']))  # noqa: E501
        if 'recurrence_type' in params:
            form_params.append(('recurrenceType', params['recurrence_type']))  # noqa: E501
        if 'recurrence_detail' in params:
            form_params.append(('recurrenceDetail', params['recurrence_detail']))  # noqa: E501
        if 'recurrence_range' in params:
            form_params.append(('recurrenceRange', params['recurrence_range']))  # noqa: E501
        if 'recurrence_repeats_on' in params:
            form_params.append(('recurrenceRepeatsOn', params['recurrence_repeats_on']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/schedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schedule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_calendar_data(self, _from, to, **kwargs):  # noqa: E501
        """Generates the calendar that we draw events on  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_calendar_data(_from, to, async=True)
        >>> result = thread.get()

        :param async bool
        :param int _from: From Date Timestamp in Microseconds (required)
        :param int to: To Date Timestamp in Microseconds (required)
        :param list[int] display_group_ids: The DisplayGroupIds to return the schedule for. Empty for All.
        :return: list[ScheduleCalendarData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.schedule_calendar_data_with_http_info(_from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_calendar_data_with_http_info(_from, to, **kwargs)  # noqa: E501
            return data

    def schedule_calendar_data_with_http_info(self, _from, to, **kwargs):  # noqa: E501
        """Generates the calendar that we draw events on  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_calendar_data_with_http_info(_from, to, async=True)
        >>> result = thread.get()

        :param async bool
        :param int _from: From Date Timestamp in Microseconds (required)
        :param int to: To Date Timestamp in Microseconds (required)
        :param list[int] display_group_ids: The DisplayGroupIds to return the schedule for. Empty for All.
        :return: list[ScheduleCalendarData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_from', 'to', 'display_group_ids']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_calendar_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter '_from' is set
        if ('_from' not in params or
                params['_from'] is None):
            raise ValueError("Missing the required parameter `_from` when calling `schedule_calendar_data`")  # noqa: E501
        # verify the required parameter 'to' is set
        if ('to' not in params or
                params['to'] is None):
            raise ValueError("Missing the required parameter `to` when calling `schedule_calendar_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'display_group_ids' in params:
            form_params.append(('displayGroupIds', params['display_group_ids']))  # noqa: E501
            collection_formats['displayGroupIds'] = 'csv'  # noqa: E501
        if '_from' in params:
            form_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            form_params.append(('to', params['to']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/schedule/data/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ScheduleCalendarData]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_calendar_data_0(self, display_group_id, date, **kwargs):  # noqa: E501
        """Event List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_calendar_data_0(display_group_id, date, async=True)
        >>> result = thread.get()

        :param async bool
        :param int display_group_id: The DisplayGroupId to return the event list for. (required)
        :param str date: Date in Y-m-d H:i:s (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.schedule_calendar_data_0_with_http_info(display_group_id, date, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_calendar_data_0_with_http_info(display_group_id, date, **kwargs)  # noqa: E501
            return data

    def schedule_calendar_data_0_with_http_info(self, display_group_id, date, **kwargs):  # noqa: E501
        """Event List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_calendar_data_0_with_http_info(display_group_id, date, async=True)
        >>> result = thread.get()

        :param async bool
        :param int display_group_id: The DisplayGroupId to return the event list for. (required)
        :param str date: Date in Y-m-d H:i:s (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['display_group_id', 'date']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_calendar_data_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'display_group_id' is set
        if ('display_group_id' not in params or
                params['display_group_id'] is None):
            raise ValueError("Missing the required parameter `display_group_id` when calling `schedule_calendar_data_0`")  # noqa: E501
        # verify the required parameter 'date' is set
        if ('date' not in params or
                params['date'] is None):
            raise ValueError("Missing the required parameter `date` when calling `schedule_calendar_data_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'display_group_id' in params:
            path_params['displayGroupId'] = params['display_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'date' in params:
            form_params.append(('date', params['date']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/schedule/{displayGroupId}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_delete(self, event_id, **kwargs):  # noqa: E501
        """Delete Event  # noqa: E501

        Delete a Scheduled Event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_delete(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: The Scheduled Event ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.schedule_delete_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_delete_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def schedule_delete_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Delete Event  # noqa: E501

        Delete a Scheduled Event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_delete_with_http_info(event_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: The Scheduled Event ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `schedule_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/schedule/{eventId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_edit(self, event_id, event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs):  # noqa: E501
        """Edit Schedule Event  # noqa: E501

        Edit a scheduled event for a Campaign/Layout to be shown on a Display Group/Display.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_edit(event_id, event_type_id, display_order, is_priority, display_group_ids, from_dt, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: The Scheduled Event ID (required)
        :param int event_type_id: The Event Type Id to use for this Event. 1=Campaign, 2=Command, 3=Overlay (required)
        :param int display_order: The display order for this event.  (required)
        :param int is_priority: An integer indicating the priority of this event. Normal events have a priority of 0. (required)
        :param list[int] display_group_ids: The Display Group IDs for this event. Display specific Group IDs should be used to schedule on single displays. (required)
        :param datetime from_dt: The from date for this event. (required)
        :param int campaign_id: The Campaign ID to use for this Event. If a Layout is needed then the Campaign specific ID for that Layout should be used.
        :param int command_id: The Command ID to use for this Event.
        :param int day_part_id: The Day Part for this event. Overrides supported are 0(custom) and 1(always). Defaulted to 0.
        :param int sync_timezone: Should this schedule be synced to the resulting Display timezone?
        :param datetime to_dt: The to date for this event.
        :param str recurrence_type: The type of recurrence to apply to this event.
        :param int recurrence_detail: The interval for the recurrence.
        :param datetime recurrence_range: The end date for this events recurrence.
        :param str recurrence_repeats_on: The days of the week that this event repeats - weekly only
        :return: Schedule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.schedule_edit_with_http_info(event_id, event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_edit_with_http_info(event_id, event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs)  # noqa: E501
            return data

    def schedule_edit_with_http_info(self, event_id, event_type_id, display_order, is_priority, display_group_ids, from_dt, **kwargs):  # noqa: E501
        """Edit Schedule Event  # noqa: E501

        Edit a scheduled event for a Campaign/Layout to be shown on a Display Group/Display.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_edit_with_http_info(event_id, event_type_id, display_order, is_priority, display_group_ids, from_dt, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: The Scheduled Event ID (required)
        :param int event_type_id: The Event Type Id to use for this Event. 1=Campaign, 2=Command, 3=Overlay (required)
        :param int display_order: The display order for this event.  (required)
        :param int is_priority: An integer indicating the priority of this event. Normal events have a priority of 0. (required)
        :param list[int] display_group_ids: The Display Group IDs for this event. Display specific Group IDs should be used to schedule on single displays. (required)
        :param datetime from_dt: The from date for this event. (required)
        :param int campaign_id: The Campaign ID to use for this Event. If a Layout is needed then the Campaign specific ID for that Layout should be used.
        :param int command_id: The Command ID to use for this Event.
        :param int day_part_id: The Day Part for this event. Overrides supported are 0(custom) and 1(always). Defaulted to 0.
        :param int sync_timezone: Should this schedule be synced to the resulting Display timezone?
        :param datetime to_dt: The to date for this event.
        :param str recurrence_type: The type of recurrence to apply to this event.
        :param int recurrence_detail: The interval for the recurrence.
        :param datetime recurrence_range: The end date for this events recurrence.
        :param str recurrence_repeats_on: The days of the week that this event repeats - weekly only
        :return: Schedule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'event_type_id', 'display_order', 'is_priority', 'display_group_ids', 'from_dt', 'campaign_id', 'command_id', 'day_part_id', 'sync_timezone', 'to_dt', 'recurrence_type', 'recurrence_detail', 'recurrence_range', 'recurrence_repeats_on']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_edit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `schedule_edit`")  # noqa: E501
        # verify the required parameter 'event_type_id' is set
        if ('event_type_id' not in params or
                params['event_type_id'] is None):
            raise ValueError("Missing the required parameter `event_type_id` when calling `schedule_edit`")  # noqa: E501
        # verify the required parameter 'display_order' is set
        if ('display_order' not in params or
                params['display_order'] is None):
            raise ValueError("Missing the required parameter `display_order` when calling `schedule_edit`")  # noqa: E501
        # verify the required parameter 'is_priority' is set
        if ('is_priority' not in params or
                params['is_priority'] is None):
            raise ValueError("Missing the required parameter `is_priority` when calling `schedule_edit`")  # noqa: E501
        # verify the required parameter 'display_group_ids' is set
        if ('display_group_ids' not in params or
                params['display_group_ids'] is None):
            raise ValueError("Missing the required parameter `display_group_ids` when calling `schedule_edit`")  # noqa: E501
        # verify the required parameter 'from_dt' is set
        if ('from_dt' not in params or
                params['from_dt'] is None):
            raise ValueError("Missing the required parameter `from_dt` when calling `schedule_edit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['eventId'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'event_type_id' in params:
            form_params.append(('eventTypeId', params['event_type_id']))  # noqa: E501
        if 'campaign_id' in params:
            form_params.append(('campaignId', params['campaign_id']))  # noqa: E501
        if 'command_id' in params:
            form_params.append(('commandId', params['command_id']))  # noqa: E501
        if 'display_order' in params:
            form_params.append(('displayOrder', params['display_order']))  # noqa: E501
        if 'is_priority' in params:
            form_params.append(('isPriority', params['is_priority']))  # noqa: E501
        if 'display_group_ids' in params:
            form_params.append(('displayGroupIds', params['display_group_ids']))  # noqa: E501
            collection_formats['displayGroupIds'] = 'csv'  # noqa: E501
        if 'day_part_id' in params:
            form_params.append(('dayPartId', params['day_part_id']))  # noqa: E501
        if 'sync_timezone' in params:
            form_params.append(('syncTimezone', params['sync_timezone']))  # noqa: E501
        if 'from_dt' in params:
            form_params.append(('fromDt', params['from_dt']))  # noqa: E501
        if 'to_dt' in params:
            form_params.append(('toDt', params['to_dt']))  # noqa: E501
        if 'recurrence_type' in params:
            form_params.append(('recurrenceType', params['recurrence_type']))  # noqa: E501
        if 'recurrence_detail' in params:
            form_params.append(('recurrenceDetail', params['recurrence_detail']))  # noqa: E501
        if 'recurrence_range' in params:
            form_params.append(('recurrenceRange', params['recurrence_range']))  # noqa: E501
        if 'recurrence_repeats_on' in params:
            form_params.append(('recurrenceRepeatsOn', params['recurrence_repeats_on']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/schedule/{eventId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schedule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

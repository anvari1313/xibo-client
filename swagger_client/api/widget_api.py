# coding: utf-8

"""
    Xibo API

    Xibo CMS API  # noqa: E501

    OpenAPI spec version: 1.8.0
    Contact: info@xibo.org.uk
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class WidgetApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def widget_assigned_audio_edit(self, widget_id, **kwargs):  # noqa: E501
        """Parameters for edting/adding audio file to a specific widget  # noqa: E501

        Parameters for edting/adding audio file to a specific widget  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_assigned_audio_edit(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: Id of a widget to which you want to add audio or edit existing audio (required)
        :param int media_id: Id of a audio file in CMS library you wish to add to a widget
        :param int volume: Volume percentage(0-100) for this audio to play at
        :param int loop: Flag (0, 1) Should the audio loop if it finishes before the widget has finished?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_assigned_audio_edit_with_http_info(widget_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_assigned_audio_edit_with_http_info(widget_id, **kwargs)  # noqa: E501
            return data

    def widget_assigned_audio_edit_with_http_info(self, widget_id, **kwargs):  # noqa: E501
        """Parameters for edting/adding audio file to a specific widget  # noqa: E501

        Parameters for edting/adding audio file to a specific widget  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_assigned_audio_edit_with_http_info(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: Id of a widget to which you want to add audio or edit existing audio (required)
        :param int media_id: Id of a audio file in CMS library you wish to add to a widget
        :param int volume: Volume percentage(0-100) for this audio to play at
        :param int loop: Flag (0, 1) Should the audio loop if it finishes before the widget has finished?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_id', 'media_id', 'volume', 'loop']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_assigned_audio_edit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_id' is set
        if ('widget_id' not in params or
                params['widget_id'] is None):
            raise ValueError("Missing the required parameter `widget_id` when calling `widget_assigned_audio_edit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'widget_id' in params:
            path_params['widgetId'] = params['widget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'media_id' in params:
            form_params.append(('mediaId', params['media_id']))  # noqa: E501
        if 'volume' in params:
            form_params.append(('volume', params['volume']))  # noqa: E501
        if 'loop' in params:
            form_params.append(('loop', params['loop']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/{widgetId}/audio', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_audio_delete(self, widget_id, **kwargs):  # noqa: E501
        """Delete assigned audio widget  # noqa: E501

        Delete assigned audio widget from specified widget ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_audio_delete(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: Id of a widget from which you want to delete the audio from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_audio_delete_with_http_info(widget_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_audio_delete_with_http_info(widget_id, **kwargs)  # noqa: E501
            return data

    def widget_audio_delete_with_http_info(self, widget_id, **kwargs):  # noqa: E501
        """Delete assigned audio widget  # noqa: E501

        Delete assigned audio widget from specified widget ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_audio_delete_with_http_info(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: Id of a widget from which you want to delete the audio from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_audio_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_id' is set
        if ('widget_id' not in params or
                params['widget_id'] is None):
            raise ValueError("Missing the required parameter `widget_id` when calling `widget_audio_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'widget_id' in params:
            path_params['widgetId'] = params['widget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/{widgetId}/audio', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_audio_edit(self, **kwargs):  # noqa: E501
        """Parameters for editing existing audio widget on a layout  # noqa: E501

        Parameters for editing existing audio widget on a layout, for adding new audio, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_audio_edit(async=True)
        >>> result = thread.get()

        :param async bool
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int duration: Edit Only - The Widget Duration
        :param str name: Edit Only - The Widget name
        :param int mute: Edit only - Flag (0, 1) Should the audio be muted?
        :param int loop: Edit only - Flag (0, 1) Should the audio loop (only for duration > 0 )?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_audio_edit_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.widget_audio_edit_with_http_info(**kwargs)  # noqa: E501
            return data

    def widget_audio_edit_with_http_info(self, **kwargs):  # noqa: E501
        """Parameters for editing existing audio widget on a layout  # noqa: E501

        Parameters for editing existing audio widget on a layout, for adding new audio, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_audio_edit_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int duration: Edit Only - The Widget Duration
        :param str name: Edit Only - The Widget name
        :param int mute: Edit only - Flag (0, 1) Should the audio be muted?
        :param int loop: Edit only - Flag (0, 1) Should the audio loop (only for duration > 0 )?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['use_duration', 'duration', 'name', 'mute', 'loop']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_audio_edit" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'mute' in params:
            form_params.append(('mute', params['mute']))  # noqa: E501
        if 'loop' in params:
            form_params.append(('loop', params['loop']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/audio/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_chart_add(self, playlist_id, data_set_id, graph_type, **kwargs):  # noqa: E501
        """Add a Chart Widget  # noqa: E501

        Add a new Chart Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_chart_add(playlist_id, data_set_id, graph_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param int data_set_id: Create Chart Widget using provided dataSetId of an existing dataSet (required)
        :param str graph_type: EDIT only - Chart Type (required)
        :param str name: Optional Widget Name
        :param list[int] column_type: EDIT only - Array of Column Types (x-axis, y-axis, series-identifier) to assign
        :param list[int] data_set_column_id: EDIT only - Array of dataSetColumn IDs to assign
        :param int duration: EDIT Only - The Chart Duration
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int update_interval: EDIT Only - Update interval in minutes
        :param str filter: EDIT Only - SQL clause for filter this dataSet
        :param str ordering: EDIT Only - SQL clause for how this dataSet should be ordered
        :param int use_ordering_clause: EDIT Only - flag (0,1) Use advanced order clause - set to 1 if ordering is provided
        :param int use_filtering_clause: EDIT Only - flag (0,1) Use advanced filter clause - set to 1 if filter is provided
        :param str background_color: EDIT Only - Background Color
        :param str font_color: EDIT Only - Font Color
        :param int font_size: EDIT Only - Font Size
        :param int show_legend: EDIT Only - Should the Legend be Shown
        :param str legend_position: EDIT Only - Where should the Legend be Shown (top, left, right, bottom)
        :param int start_y_at_zero: EDIT Only - Start the Y-Axis at 0
        :param str title: EDIT Only - Chart title
        :param str x_axis_label: EDIT Only - Chart x-axis label
        :param str y_axis_label: EDIT Only - Chart y-axis label
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_chart_add_with_http_info(playlist_id, data_set_id, graph_type, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_chart_add_with_http_info(playlist_id, data_set_id, graph_type, **kwargs)  # noqa: E501
            return data

    def widget_chart_add_with_http_info(self, playlist_id, data_set_id, graph_type, **kwargs):  # noqa: E501
        """Add a Chart Widget  # noqa: E501

        Add a new Chart Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_chart_add_with_http_info(playlist_id, data_set_id, graph_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param int data_set_id: Create Chart Widget using provided dataSetId of an existing dataSet (required)
        :param str graph_type: EDIT only - Chart Type (required)
        :param str name: Optional Widget Name
        :param list[int] column_type: EDIT only - Array of Column Types (x-axis, y-axis, series-identifier) to assign
        :param list[int] data_set_column_id: EDIT only - Array of dataSetColumn IDs to assign
        :param int duration: EDIT Only - The Chart Duration
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int update_interval: EDIT Only - Update interval in minutes
        :param str filter: EDIT Only - SQL clause for filter this dataSet
        :param str ordering: EDIT Only - SQL clause for how this dataSet should be ordered
        :param int use_ordering_clause: EDIT Only - flag (0,1) Use advanced order clause - set to 1 if ordering is provided
        :param int use_filtering_clause: EDIT Only - flag (0,1) Use advanced filter clause - set to 1 if filter is provided
        :param str background_color: EDIT Only - Background Color
        :param str font_color: EDIT Only - Font Color
        :param int font_size: EDIT Only - Font Size
        :param int show_legend: EDIT Only - Should the Legend be Shown
        :param str legend_position: EDIT Only - Where should the Legend be Shown (top, left, right, bottom)
        :param int start_y_at_zero: EDIT Only - Start the Y-Axis at 0
        :param str title: EDIT Only - Chart title
        :param str x_axis_label: EDIT Only - Chart x-axis label
        :param str y_axis_label: EDIT Only - Chart y-axis label
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'data_set_id', 'graph_type', 'name', 'column_type', 'data_set_column_id', 'duration', 'use_duration', 'update_interval', 'filter', 'ordering', 'use_ordering_clause', 'use_filtering_clause', 'background_color', 'font_color', 'font_size', 'show_legend', 'legend_position', 'start_y_at_zero', 'title', 'x_axis_label', 'y_axis_label']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_chart_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_chart_add`")  # noqa: E501
        # verify the required parameter 'data_set_id' is set
        if ('data_set_id' not in params or
                params['data_set_id'] is None):
            raise ValueError("Missing the required parameter `data_set_id` when calling `widget_chart_add`")  # noqa: E501
        # verify the required parameter 'graph_type' is set
        if ('graph_type' not in params or
                params['graph_type'] is None):
            raise ValueError("Missing the required parameter `graph_type` when calling `widget_chart_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'data_set_id' in params:
            form_params.append(('dataSetId', params['data_set_id']))  # noqa: E501
        if 'graph_type' in params:
            form_params.append(('graphType', params['graph_type']))  # noqa: E501
        if 'column_type' in params:
            form_params.append(('columnType', params['column_type']))  # noqa: E501
            collection_formats['columnType'] = 'csv'  # noqa: E501
        if 'data_set_column_id' in params:
            form_params.append(('dataSetColumnId', params['data_set_column_id']))  # noqa: E501
            collection_formats['dataSetColumnId'] = 'csv'  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'filter' in params:
            form_params.append(('filter', params['filter']))  # noqa: E501
        if 'ordering' in params:
            form_params.append(('ordering', params['ordering']))  # noqa: E501
        if 'use_ordering_clause' in params:
            form_params.append(('useOrderingClause', params['use_ordering_clause']))  # noqa: E501
        if 'use_filtering_clause' in params:
            form_params.append(('useFilteringClause', params['use_filtering_clause']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'font_color' in params:
            form_params.append(('fontColor', params['font_color']))  # noqa: E501
        if 'font_size' in params:
            form_params.append(('fontSize', params['font_size']))  # noqa: E501
        if 'show_legend' in params:
            form_params.append(('showLegend', params['show_legend']))  # noqa: E501
        if 'legend_position' in params:
            form_params.append(('legendPosition', params['legend_position']))  # noqa: E501
        if 'start_y_at_zero' in params:
            form_params.append(('startYAtZero', params['start_y_at_zero']))  # noqa: E501
        if 'title' in params:
            form_params.append(('title', params['title']))  # noqa: E501
        if 'x_axis_label' in params:
            form_params.append(('x-axis-label', params['x_axis_label']))  # noqa: E501
        if 'y_axis_label' in params:
            form_params.append(('y-axis-label', params['y_axis_label']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/chart/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_clock_add(self, playlist_id, **kwargs):  # noqa: E501
        """Add a Clock Widget  # noqa: E501

        Add a new Clock Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_clock_add(playlist_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Clock widget to (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int theme_id: Flag (0 , 1) for Analogue clock the light and dark theme
        :param int clock_type_id: Type of a clock widget 1-Analogue, 2-Digital, 3-Flip clock
        :param str offset: The offset in minutes that should be applied to the current time, if a counter is selected then date/time to run from in the format Y-m-d H:i:s
        :param str format: For digital clock, format in which the time should be displayed example [HH:mm]
        :param int show_seconds: For Flip Clock, should the clock show seconds or not
        :param str clock_face: For Flip Clock, supported options: TwelveHourClock TwentyFourHourClock HourlyCounter MinuteCounter DailyCounter
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_clock_add_with_http_info(playlist_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_clock_add_with_http_info(playlist_id, **kwargs)  # noqa: E501
            return data

    def widget_clock_add_with_http_info(self, playlist_id, **kwargs):  # noqa: E501
        """Add a Clock Widget  # noqa: E501

        Add a new Clock Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_clock_add_with_http_info(playlist_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Clock widget to (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int theme_id: Flag (0 , 1) for Analogue clock the light and dark theme
        :param int clock_type_id: Type of a clock widget 1-Analogue, 2-Digital, 3-Flip clock
        :param str offset: The offset in minutes that should be applied to the current time, if a counter is selected then date/time to run from in the format Y-m-d H:i:s
        :param str format: For digital clock, format in which the time should be displayed example [HH:mm]
        :param int show_seconds: For Flip Clock, should the clock show seconds or not
        :param str clock_face: For Flip Clock, supported options: TwelveHourClock TwentyFourHourClock HourlyCounter MinuteCounter DailyCounter
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'name', 'duration', 'use_duration', 'theme_id', 'clock_type_id', 'offset', 'format', 'show_seconds', 'clock_face']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_clock_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_clock_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'theme_id' in params:
            form_params.append(('themeId', params['theme_id']))  # noqa: E501
        if 'clock_type_id' in params:
            form_params.append(('clockTypeId', params['clock_type_id']))  # noqa: E501
        if 'offset' in params:
            form_params.append(('offset', params['offset']))  # noqa: E501
        if 'format' in params:
            form_params.append(('format', params['format']))  # noqa: E501
        if 'show_seconds' in params:
            form_params.append(('showSeconds', params['show_seconds']))  # noqa: E501
        if 'clock_face' in params:
            form_params.append(('ClockFace', params['clock_face']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/clock/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_currencies_add(self, playlist_id, base, items, **kwargs):  # noqa: E501
        """Add a Currencies Widget  # noqa: E501

        Add a new Currencies Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_currencies_add(playlist_id, base, items, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Currencies widget (required)
        :param str base: The base currency (required)
        :param str items: Items wanted (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int reverse_conversion: (0, 1) Select 1 if you'd like your base currency to be used as the comparison currency you've entered
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_records_message: A message to display when there are no records returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param int duration_is_per_page: A flag (0, 1), The duration specified is per page/item, otherwise the widget duration is divided between the number of pages/items
        :param str template_id: Use pre-configured templates, available options: currencies1, currencies2
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int widget_original_width: This is the intended Width of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_height: This is the intended Height of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int max_items_per_page: This is the intended number of items on each page
        :param str main_template: Main template, Pass only with overrideTemplate set to 1 
        :param str itemtemplate: Template for each item, replaces [itemsTemplate] in main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_currencies_add_with_http_info(playlist_id, base, items, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_currencies_add_with_http_info(playlist_id, base, items, **kwargs)  # noqa: E501
            return data

    def widget_currencies_add_with_http_info(self, playlist_id, base, items, **kwargs):  # noqa: E501
        """Add a Currencies Widget  # noqa: E501

        Add a new Currencies Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_currencies_add_with_http_info(playlist_id, base, items, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Currencies widget (required)
        :param str base: The base currency (required)
        :param str items: Items wanted (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int reverse_conversion: (0, 1) Select 1 if you'd like your base currency to be used as the comparison currency you've entered
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_records_message: A message to display when there are no records returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param int duration_is_per_page: A flag (0, 1), The duration specified is per page/item, otherwise the widget duration is divided between the number of pages/items
        :param str template_id: Use pre-configured templates, available options: currencies1, currencies2
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int widget_original_width: This is the intended Width of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_height: This is the intended Height of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int max_items_per_page: This is the intended number of items on each page
        :param str main_template: Main template, Pass only with overrideTemplate set to 1 
        :param str itemtemplate: Template for each item, replaces [itemsTemplate] in main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'base', 'items', 'name', 'duration', 'use_duration', 'reverse_conversion', 'effect', 'speed', 'background_color', 'no_records_message', 'date_format', 'update_interval', 'duration_is_per_page', 'template_id', 'override_template', 'widget_original_width', 'widget_original_height', 'max_items_per_page', 'main_template', 'itemtemplate', 'style_sheet', 'java_script']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_currencies_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_currencies_add`")  # noqa: E501
        # verify the required parameter 'base' is set
        if ('base' not in params or
                params['base'] is None):
            raise ValueError("Missing the required parameter `base` when calling `widget_currencies_add`")  # noqa: E501
        # verify the required parameter 'items' is set
        if ('items' not in params or
                params['items'] is None):
            raise ValueError("Missing the required parameter `items` when calling `widget_currencies_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'base' in params:
            form_params.append(('base', params['base']))  # noqa: E501
        if 'items' in params:
            form_params.append(('items', params['items']))  # noqa: E501
        if 'reverse_conversion' in params:
            form_params.append(('reverseConversion', params['reverse_conversion']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'no_records_message' in params:
            form_params.append(('noRecordsMessage', params['no_records_message']))  # noqa: E501
        if 'date_format' in params:
            form_params.append(('dateFormat', params['date_format']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'duration_is_per_page' in params:
            form_params.append(('durationIsPerPage', params['duration_is_per_page']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'widget_original_width' in params:
            form_params.append(('widgetOriginalWidth', params['widget_original_width']))  # noqa: E501
        if 'widget_original_height' in params:
            form_params.append(('widgetOriginalHeight', params['widget_original_height']))  # noqa: E501
        if 'max_items_per_page' in params:
            form_params.append(('maxItemsPerPage', params['max_items_per_page']))  # noqa: E501
        if 'main_template' in params:
            form_params.append(('mainTemplate', params['main_template']))  # noqa: E501
        if 'itemtemplate' in params:
            form_params.append(('itemtemplate', params['itemtemplate']))  # noqa: E501
        if 'style_sheet' in params:
            form_params.append(('styleSheet', params['style_sheet']))  # noqa: E501
        if 'java_script' in params:
            form_params.append(('javaScript', params['java_script']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/currencies/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_delete(self, widget_id, **kwargs):  # noqa: E501
        """Delete a Widget  # noqa: E501

        Deleted a specified widget  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_delete(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: The widget ID to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_delete_with_http_info(widget_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_delete_with_http_info(widget_id, **kwargs)  # noqa: E501
            return data

    def widget_delete_with_http_info(self, widget_id, **kwargs):  # noqa: E501
        """Delete a Widget  # noqa: E501

        Deleted a specified widget  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_delete_with_http_info(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: The widget ID to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_id' is set
        if ('widget_id' not in params or
                params['widget_id'] is None):
            raise ValueError("Missing the required parameter `widget_id` when calling `widget_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'widget_id' in params:
            path_params['widgetId'] = params['widget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/{widgetId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_edit(self, widget_id, **kwargs):  # noqa: E501
        """Edit a Widget  # noqa: E501

        Edit a Widget, please refer to individual widget Add documentation for module specific parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_edit(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: The widget ID to edit (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_edit_with_http_info(widget_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_edit_with_http_info(widget_id, **kwargs)  # noqa: E501
            return data

    def widget_edit_with_http_info(self, widget_id, **kwargs):  # noqa: E501
        """Edit a Widget  # noqa: E501

        Edit a Widget, please refer to individual widget Add documentation for module specific parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_edit_with_http_info(widget_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int widget_id: The widget ID to edit (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['widget_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_edit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'widget_id' is set
        if ('widget_id' not in params or
                params['widget_id'] is None):
            raise ValueError("Missing the required parameter `widget_id` when calling `widget_edit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'widget_id' in params:
            path_params['widgetId'] = params['widget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/{widgetId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_edit_transition(self, type, widget_id, transition_type, **kwargs):  # noqa: E501
        """Adds In/Out transition  # noqa: E501

        Adds In/Out transition to a specified widget  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_edit_transition(type, widget_id, transition_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str type: Transition type, available options: in, out (required)
        :param int widget_id: The widget ID to add the transition to (required)
        :param str transition_type: Type of a transition, available Options: fly, fadeIn, fadeOut (required)
        :param int transition_duration: Duration of this transition in milliseconds
        :param int transition_direction: The direction for this transition, only appropriate for transitions that move, such as fly. Available options: N, NE, E, SE, S, SW, W, NW
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_edit_transition_with_http_info(type, widget_id, transition_type, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_edit_transition_with_http_info(type, widget_id, transition_type, **kwargs)  # noqa: E501
            return data

    def widget_edit_transition_with_http_info(self, type, widget_id, transition_type, **kwargs):  # noqa: E501
        """Adds In/Out transition  # noqa: E501

        Adds In/Out transition to a specified widget  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_edit_transition_with_http_info(type, widget_id, transition_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str type: Transition type, available options: in, out (required)
        :param int widget_id: The widget ID to add the transition to (required)
        :param str transition_type: Type of a transition, available Options: fly, fadeIn, fadeOut (required)
        :param int transition_duration: Duration of this transition in milliseconds
        :param int transition_direction: The direction for this transition, only appropriate for transitions that move, such as fly. Available options: N, NE, E, SE, S, SW, W, NW
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'widget_id', 'transition_type', 'transition_duration', 'transition_direction']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_edit_transition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `widget_edit_transition`")  # noqa: E501
        # verify the required parameter 'widget_id' is set
        if ('widget_id' not in params or
                params['widget_id'] is None):
            raise ValueError("Missing the required parameter `widget_id` when calling `widget_edit_transition`")  # noqa: E501
        # verify the required parameter 'transition_type' is set
        if ('transition_type' not in params or
                params['transition_type'] is None):
            raise ValueError("Missing the required parameter `transition_type` when calling `widget_edit_transition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'widget_id' in params:
            path_params['widgetId'] = params['widget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'transition_type' in params:
            form_params.append(('transitionType', params['transition_type']))  # noqa: E501
        if 'transition_duration' in params:
            form_params.append(('transitionDuration', params['transition_duration']))  # noqa: E501
        if 'transition_direction' in params:
            form_params.append(('transitionDirection', params['transition_direction']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/transition/{type}/{widgetId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_embedded_add(self, playlist_id, **kwargs):  # noqa: E501
        """Add a Embedded Widget  # noqa: E501

        Add a new Embedded Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_embedded_add(playlist_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add an Embedded Widget (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int transparency: Flag (0,1) - Should the HTML be shown with transparent background? - not available on Windows Clients
        :param int scale_content: Flag (0,1) - Should the embedded content be scaled along with the layout?
        :param str embed_html: HTML to embed
        :param str embed_script: HEAD content to Embed (including script tags)
        :param str embed_style: Custom Style Sheets (CSS)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_embedded_add_with_http_info(playlist_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_embedded_add_with_http_info(playlist_id, **kwargs)  # noqa: E501
            return data

    def widget_embedded_add_with_http_info(self, playlist_id, **kwargs):  # noqa: E501
        """Add a Embedded Widget  # noqa: E501

        Add a new Embedded Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_embedded_add_with_http_info(playlist_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add an Embedded Widget (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int transparency: Flag (0,1) - Should the HTML be shown with transparent background? - not available on Windows Clients
        :param int scale_content: Flag (0,1) - Should the embedded content be scaled along with the layout?
        :param str embed_html: HTML to embed
        :param str embed_script: HEAD content to Embed (including script tags)
        :param str embed_style: Custom Style Sheets (CSS)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'name', 'duration', 'use_duration', 'transparency', 'scale_content', 'embed_html', 'embed_script', 'embed_style']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_embedded_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_embedded_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'transparency' in params:
            form_params.append(('transparency', params['transparency']))  # noqa: E501
        if 'scale_content' in params:
            form_params.append(('scaleContent', params['scale_content']))  # noqa: E501
        if 'embed_html' in params:
            form_params.append(('embedHtml', params['embed_html']))  # noqa: E501
        if 'embed_script' in params:
            form_params.append(('embedScript', params['embed_script']))  # noqa: E501
        if 'embed_style' in params:
            form_params.append(('embedStyle', params['embed_style']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/embedded/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_finance_add(self, playlist_id, item, yql, **kwargs):  # noqa: E501
        """Add a Finance Widget  # noqa: E501

        Add a new Finance Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_finance_add(playlist_id, item, yql, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Finance widget (required)
        :param str item: Items wanted, can be comma separated (example EURUSD, GBPUSD), pass only with overrideTemplate set to 1 (required)
        :param str yql: The YQL query to use for data, pass only with overrideTemplate set to 1 (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind, marqueeUp, marqueeDown, marqueeRight, marqueeLeft
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal) or the Marquee speed in a low to high scale (normal = 1)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_records_message: A message to display when there are no records returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str template_id: Use pre-configured templates, available options: currency-simple, stock-simple
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per item, otherwise the widget duration is divided between the number of items
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param str result_identifier: The name of the result identifier returned by the YQL, pass only with overrideTemplate set to 1
        :param str template: Main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_finance_add_with_http_info(playlist_id, item, yql, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_finance_add_with_http_info(playlist_id, item, yql, **kwargs)  # noqa: E501
            return data

    def widget_finance_add_with_http_info(self, playlist_id, item, yql, **kwargs):  # noqa: E501
        """Add a Finance Widget  # noqa: E501

        Add a new Finance Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_finance_add_with_http_info(playlist_id, item, yql, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Finance widget (required)
        :param str item: Items wanted, can be comma separated (example EURUSD, GBPUSD), pass only with overrideTemplate set to 1 (required)
        :param str yql: The YQL query to use for data, pass only with overrideTemplate set to 1 (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind, marqueeUp, marqueeDown, marqueeRight, marqueeLeft
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal) or the Marquee speed in a low to high scale (normal = 1)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_records_message: A message to display when there are no records returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str template_id: Use pre-configured templates, available options: currency-simple, stock-simple
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per item, otherwise the widget duration is divided between the number of items
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param str result_identifier: The name of the result identifier returned by the YQL, pass only with overrideTemplate set to 1
        :param str template: Main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'item', 'yql', 'name', 'duration', 'use_duration', 'effect', 'speed', 'background_color', 'no_records_message', 'date_format', 'update_interval', 'template_id', 'duration_is_per_item', 'override_template', 'result_identifier', 'template', 'style_sheet', 'java_script']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_finance_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_finance_add`")  # noqa: E501
        # verify the required parameter 'item' is set
        if ('item' not in params or
                params['item'] is None):
            raise ValueError("Missing the required parameter `item` when calling `widget_finance_add`")  # noqa: E501
        # verify the required parameter 'yql' is set
        if ('yql' not in params or
                params['yql'] is None):
            raise ValueError("Missing the required parameter `yql` when calling `widget_finance_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'item' in params:
            form_params.append(('item', params['item']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'no_records_message' in params:
            form_params.append(('noRecordsMessage', params['no_records_message']))  # noqa: E501
        if 'date_format' in params:
            form_params.append(('dateFormat', params['date_format']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'duration_is_per_item' in params:
            form_params.append(('durationIsPerItem', params['duration_is_per_item']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'yql' in params:
            form_params.append(('yql', params['yql']))  # noqa: E501
        if 'result_identifier' in params:
            form_params.append(('resultIdentifier', params['result_identifier']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501
        if 'style_sheet' in params:
            form_params.append(('styleSheet', params['style_sheet']))  # noqa: E501
        if 'java_script' in params:
            form_params.append(('javaScript', params['java_script']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/finance/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_google_traffic_add(self, playlist_id, zoom, use_display_location, **kwargs):  # noqa: E501
        """Add a Google Traffic Widget  # noqa: E501

        Add a new Google traffic Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_google_traffic_add(playlist_id, zoom, use_display_location, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget (required)
        :param int zoom: How far should the map be zoomed in? The higher the number the closer the zoom, 1 represents entire globe (required)
        :param int use_display_location: Flag (0, 1) Use the location configured on display (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param float longitude: The longitude for this weather widget, only pass if useDisplayLocation set to 0
        :param float latitude: The latitude for this weather widget, only pass if useDisplayLocation set to 0
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_google_traffic_add_with_http_info(playlist_id, zoom, use_display_location, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_google_traffic_add_with_http_info(playlist_id, zoom, use_display_location, **kwargs)  # noqa: E501
            return data

    def widget_google_traffic_add_with_http_info(self, playlist_id, zoom, use_display_location, **kwargs):  # noqa: E501
        """Add a Google Traffic Widget  # noqa: E501

        Add a new Google traffic Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_google_traffic_add_with_http_info(playlist_id, zoom, use_display_location, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget (required)
        :param int zoom: How far should the map be zoomed in? The higher the number the closer the zoom, 1 represents entire globe (required)
        :param int use_display_location: Flag (0, 1) Use the location configured on display (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param float longitude: The longitude for this weather widget, only pass if useDisplayLocation set to 0
        :param float latitude: The latitude for this weather widget, only pass if useDisplayLocation set to 0
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'zoom', 'use_display_location', 'name', 'duration', 'use_duration', 'longitude', 'latitude']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_google_traffic_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_google_traffic_add`")  # noqa: E501
        # verify the required parameter 'zoom' is set
        if ('zoom' not in params or
                params['zoom'] is None):
            raise ValueError("Missing the required parameter `zoom` when calling `widget_google_traffic_add`")  # noqa: E501
        # verify the required parameter 'use_display_location' is set
        if ('use_display_location' not in params or
                params['use_display_location'] is None):
            raise ValueError("Missing the required parameter `use_display_location` when calling `widget_google_traffic_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'zoom' in params:
            form_params.append(('zoom', params['zoom']))  # noqa: E501
        if 'use_display_location' in params:
            form_params.append(('useDisplayLocation', params['use_display_location']))  # noqa: E501
        if 'longitude' in params:
            form_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'latitude' in params:
            form_params.append(('latitude', params['latitude']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/googleTraffic/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_hls_add(self, playlist_id, uri, **kwargs):  # noqa: E501
        """Add a HLS Widget  # noqa: E501

        Add a new HLS Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_hls_add(playlist_id, uri, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str uri: URL to HLS video stream (required)
        :param str name: Optional Widget Name
        :param int use_duration: Edit Only - (0, 1) Select only if you will provide duration parameter as well
        :param int duration: The Widget Duration
        :param int mute: Flag (0, 1) Should the video be muted?
        :param int transparency: Flag (0, 1), This causes some android devices to switch to a hardware accelerated web view
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_hls_add_with_http_info(playlist_id, uri, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_hls_add_with_http_info(playlist_id, uri, **kwargs)  # noqa: E501
            return data

    def widget_hls_add_with_http_info(self, playlist_id, uri, **kwargs):  # noqa: E501
        """Add a HLS Widget  # noqa: E501

        Add a new HLS Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_hls_add_with_http_info(playlist_id, uri, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str uri: URL to HLS video stream (required)
        :param str name: Optional Widget Name
        :param int use_duration: Edit Only - (0, 1) Select only if you will provide duration parameter as well
        :param int duration: The Widget Duration
        :param int mute: Flag (0, 1) Should the video be muted?
        :param int transparency: Flag (0, 1), This causes some android devices to switch to a hardware accelerated web view
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'uri', 'name', 'use_duration', 'duration', 'mute', 'transparency']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_hls_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_hls_add`")  # noqa: E501
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `widget_hls_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'uri' in params:
            form_params.append(('uri', params['uri']))  # noqa: E501
        if 'mute' in params:
            form_params.append(('mute', params['mute']))  # noqa: E501
        if 'transparency' in params:
            form_params.append(('transparency', params['transparency']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/hls/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_image_edit(self, **kwargs):  # noqa: E501
        """Parameters for editing existing image on a layout  # noqa: E501

        Parameters for editing existing image on a layout, for adding new images, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_image_edit(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Edit only - Optional Widget Name
        :param int duration: Edit Only - The Widget Duration
        :param int use_duration: Edit only (0, 1) Select 1 only if you will provide duration parameter as well
        :param str scale_type_id: Edit only - Select scale type available options: center, stretch
        :param str align_id: Edit only - Horizontal alignment - left, center, bottom
        :param str valign_id: Edit only - Vertical alignment - top, middle, bottom
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_image_edit_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.widget_image_edit_with_http_info(**kwargs)  # noqa: E501
            return data

    def widget_image_edit_with_http_info(self, **kwargs):  # noqa: E501
        """Parameters for editing existing image on a layout  # noqa: E501

        Parameters for editing existing image on a layout, for adding new images, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_image_edit_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Edit only - Optional Widget Name
        :param int duration: Edit Only - The Widget Duration
        :param int use_duration: Edit only (0, 1) Select 1 only if you will provide duration parameter as well
        :param str scale_type_id: Edit only - Select scale type available options: center, stretch
        :param str align_id: Edit only - Horizontal alignment - left, center, bottom
        :param str valign_id: Edit only - Vertical alignment - top, middle, bottom
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'duration', 'use_duration', 'scale_type_id', 'align_id', 'valign_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_image_edit" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'scale_type_id' in params:
            form_params.append(('scaleTypeId', params['scale_type_id']))  # noqa: E501
        if 'align_id' in params:
            form_params.append(('alignId', params['align_id']))  # noqa: E501
        if 'valign_id' in params:
            form_params.append(('valignId', params['valign_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/image/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_local_video_add(self, playlist_id, uri, **kwargs):  # noqa: E501
        """Add a Local Video Widget  # noqa: E501

        Add a new Local Video Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_local_video_add(playlist_id, uri, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str uri: A local file path or URL to the video. This can be RTSP stream. (required)
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str scale_type_id: How should the video be scaled, available options: aspect, stretch
        :param int mute: Flag (0, 1) Should the video be muted?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_local_video_add_with_http_info(playlist_id, uri, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_local_video_add_with_http_info(playlist_id, uri, **kwargs)  # noqa: E501
            return data

    def widget_local_video_add_with_http_info(self, playlist_id, uri, **kwargs):  # noqa: E501
        """Add a Local Video Widget  # noqa: E501

        Add a new Local Video Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_local_video_add_with_http_info(playlist_id, uri, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str uri: A local file path or URL to the video. This can be RTSP stream. (required)
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str scale_type_id: How should the video be scaled, available options: aspect, stretch
        :param int mute: Flag (0, 1) Should the video be muted?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'uri', 'duration', 'use_duration', 'scale_type_id', 'mute']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_local_video_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_local_video_add`")  # noqa: E501
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `widget_local_video_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'uri' in params:
            form_params.append(('uri', params['uri']))  # noqa: E501
        if 'scale_type_id' in params:
            form_params.append(('scaleTypeId', params['scale_type_id']))  # noqa: E501
        if 'mute' in params:
            form_params.append(('mute', params['mute']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/localVideo/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_notification_add(self, playlist_id, age, **kwargs):  # noqa: E501
        """Add a Notification Widget  # noqa: E501

        Add a new Notification Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_notification_add(playlist_id, age, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add an Notification Widget (required)
        :param int age: The maximum notification age in minutes - 0 for all (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str no_data_message: Message to show when no notifications are available
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per page/item, otherwise the widget duration is divided between the number of pages/items
        :param str embed_style: Custom Style Sheets (CSS)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_notification_add_with_http_info(playlist_id, age, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_notification_add_with_http_info(playlist_id, age, **kwargs)  # noqa: E501
            return data

    def widget_notification_add_with_http_info(self, playlist_id, age, **kwargs):  # noqa: E501
        """Add a Notification Widget  # noqa: E501

        Add a new Notification Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_notification_add_with_http_info(playlist_id, age, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add an Notification Widget (required)
        :param int age: The maximum notification age in minutes - 0 for all (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str no_data_message: Message to show when no notifications are available
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per page/item, otherwise the widget duration is divided between the number of pages/items
        :param str embed_style: Custom Style Sheets (CSS)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'age', 'name', 'duration', 'use_duration', 'no_data_message', 'effect', 'speed', 'duration_is_per_item', 'embed_style']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_notification_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_notification_add`")  # noqa: E501
        # verify the required parameter 'age' is set
        if ('age' not in params or
                params['age'] is None):
            raise ValueError("Missing the required parameter `age` when calling `widget_notification_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'age' in params:
            form_params.append(('age', params['age']))  # noqa: E501
        if 'no_data_message' in params:
            form_params.append(('noDataMessage', params['no_data_message']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'duration_is_per_item' in params:
            form_params.append(('durationIsPerItem', params['duration_is_per_item']))  # noqa: E501
        if 'embed_style' in params:
            form_params.append(('embedStyle', params['embed_style']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/notificationview/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_pdf_edit(self, **kwargs):  # noqa: E501
        """Parameters for editing existing pdf on a layout  # noqa: E501

        Parameters for editing existing pdf on a layout, for adding new files, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_pdf_edit(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Edit only - Optional Widget Name
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int duration: Edit Only - The Widget Duration
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_pdf_edit_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.widget_pdf_edit_with_http_info(**kwargs)  # noqa: E501
            return data

    def widget_pdf_edit_with_http_info(self, **kwargs):  # noqa: E501
        """Parameters for editing existing pdf on a layout  # noqa: E501

        Parameters for editing existing pdf on a layout, for adding new files, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_pdf_edit_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Edit only - Optional Widget Name
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int duration: Edit Only - The Widget Duration
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'use_duration', 'duration']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_pdf_edit" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/pdf/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_shell_command_add(self, playlist_id, **kwargs):  # noqa: E501
        """Add a Shell Command Widget  # noqa: E501

        Add a new Shell Command Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_shell_command_add(playlist_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str windows_command: Enter a Windows command line compatible command
        :param str linux_command: Enter a Android / Linux command line compatible command
        :param int launch_through_cmd: flag (0,1) Windows only, Should the player launch this command through the windows command line (cmd.exe)? This is useful for batch files, if you try to terminate this command only the command line will be terminated
        :param int terminate_command: flag (0,1) Should the player forcefully terminate the command after the duration specified, 0 to let the command terminate naturally
        :param int use_taskkill: flag (0,1) Windows only, should the player use taskkill to terminate commands
        :param str command_code: Enter a reference code for exiting command in CMS
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_shell_command_add_with_http_info(playlist_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_shell_command_add_with_http_info(playlist_id, **kwargs)  # noqa: E501
            return data

    def widget_shell_command_add_with_http_info(self, playlist_id, **kwargs):  # noqa: E501
        """Add a Shell Command Widget  # noqa: E501

        Add a new Shell Command Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_shell_command_add_with_http_info(playlist_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str windows_command: Enter a Windows command line compatible command
        :param str linux_command: Enter a Android / Linux command line compatible command
        :param int launch_through_cmd: flag (0,1) Windows only, Should the player launch this command through the windows command line (cmd.exe)? This is useful for batch files, if you try to terminate this command only the command line will be terminated
        :param int terminate_command: flag (0,1) Should the player forcefully terminate the command after the duration specified, 0 to let the command terminate naturally
        :param int use_taskkill: flag (0,1) Windows only, should the player use taskkill to terminate commands
        :param str command_code: Enter a reference code for exiting command in CMS
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'name', 'duration', 'use_duration', 'windows_command', 'linux_command', 'launch_through_cmd', 'terminate_command', 'use_taskkill', 'command_code']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_shell_command_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_shell_command_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'windows_command' in params:
            form_params.append(('windowsCommand', params['windows_command']))  # noqa: E501
        if 'linux_command' in params:
            form_params.append(('linuxCommand', params['linux_command']))  # noqa: E501
        if 'launch_through_cmd' in params:
            form_params.append(('launchThroughCmd', params['launch_through_cmd']))  # noqa: E501
        if 'terminate_command' in params:
            form_params.append(('terminateCommand', params['terminate_command']))  # noqa: E501
        if 'use_taskkill' in params:
            form_params.append(('useTaskkill', params['use_taskkill']))  # noqa: E501
        if 'command_code' in params:
            form_params.append(('commandCode', params['command_code']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/shellCommand/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_stocks_add(self, playlist_id, items, **kwargs):  # noqa: E501
        """Add a Stocks Widget  # noqa: E501

        Add a new Stocks Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_stocks_add(playlist_id, items, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Stocks widget (required)
        :param str items: Items wanted, can be comma separated (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_records_message: A message to display when there are no records returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str template_id: Use pre-configured templates, available options: stocks1, stocks2
        :param int duration_is_per_page: A flag (0, 1), The duration specified is per page, otherwise the widget duration is divided between the number of pages/items
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int max_items_per_page: This is the intended number of items on each page
        :param str main_template: Main template, Pass only with overrideTemplate set to 1
        :param str itemtemplate: Template for each item, replaces [itemsTemplate] in main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_stocks_add_with_http_info(playlist_id, items, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_stocks_add_with_http_info(playlist_id, items, **kwargs)  # noqa: E501
            return data

    def widget_stocks_add_with_http_info(self, playlist_id, items, **kwargs):  # noqa: E501
        """Add a Stocks Widget  # noqa: E501

        Add a new Stocks Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_stocks_add_with_http_info(playlist_id, items, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Stocks widget (required)
        :param str items: Items wanted, can be comma separated (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_records_message: A message to display when there are no records returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str template_id: Use pre-configured templates, available options: stocks1, stocks2
        :param int duration_is_per_page: A flag (0, 1), The duration specified is per page, otherwise the widget duration is divided between the number of pages/items
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int max_items_per_page: This is the intended number of items on each page
        :param str main_template: Main template, Pass only with overrideTemplate set to 1
        :param str itemtemplate: Template for each item, replaces [itemsTemplate] in main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'items', 'name', 'duration', 'use_duration', 'effect', 'speed', 'background_color', 'no_records_message', 'date_format', 'update_interval', 'template_id', 'duration_is_per_page', 'override_template', 'max_items_per_page', 'main_template', 'itemtemplate', 'style_sheet', 'java_script']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_stocks_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_stocks_add`")  # noqa: E501
        # verify the required parameter 'items' is set
        if ('items' not in params or
                params['items'] is None):
            raise ValueError("Missing the required parameter `items` when calling `widget_stocks_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'items' in params:
            form_params.append(('items', params['items']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'no_records_message' in params:
            form_params.append(('noRecordsMessage', params['no_records_message']))  # noqa: E501
        if 'date_format' in params:
            form_params.append(('dateFormat', params['date_format']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'duration_is_per_page' in params:
            form_params.append(('durationIsPerPage', params['duration_is_per_page']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'max_items_per_page' in params:
            form_params.append(('maxItemsPerPage', params['max_items_per_page']))  # noqa: E501
        if 'main_template' in params:
            form_params.append(('mainTemplate', params['main_template']))  # noqa: E501
        if 'itemtemplate' in params:
            form_params.append(('itemtemplate', params['itemtemplate']))  # noqa: E501
        if 'style_sheet' in params:
            form_params.append(('styleSheet', params['style_sheet']))  # noqa: E501
        if 'java_script' in params:
            form_params.append(('javaScript', params['java_script']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/stocks/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_text_add(self, playlist_id, text, **kwargs):  # noqa: E501
        """Add a Text Widget  # noqa: E501

        Add a new Text Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_text_add(playlist_id, text, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str text: Enter the text to display (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind, marqueeUp, marqueeDown, marqueeRight, marqueeLeft
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal) or the Marquee speed in a low to high scale (normal = 1)
        :param str backgroundcolor: A HEX color to use as the background color of this widget
        :param str marquee_inline_selector: The selector to use for stacking marquee items in a line when scrolling left/right
        :param str java_script: Optional JavaScript
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_text_add_with_http_info(playlist_id, text, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_text_add_with_http_info(playlist_id, text, **kwargs)  # noqa: E501
            return data

    def widget_text_add_with_http_info(self, playlist_id, text, **kwargs):  # noqa: E501
        """Add a Text Widget  # noqa: E501

        Add a new Text Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_text_add_with_http_info(playlist_id, text, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str text: Enter the text to display (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind, marqueeUp, marqueeDown, marqueeRight, marqueeLeft
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal) or the Marquee speed in a low to high scale (normal = 1)
        :param str backgroundcolor: A HEX color to use as the background color of this widget
        :param str marquee_inline_selector: The selector to use for stacking marquee items in a line when scrolling left/right
        :param str java_script: Optional JavaScript
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'text', 'name', 'duration', 'use_duration', 'effect', 'speed', 'backgroundcolor', 'marquee_inline_selector', 'java_script']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_text_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_text_add`")  # noqa: E501
        # verify the required parameter 'text' is set
        if ('text' not in params or
                params['text'] is None):
            raise ValueError("Missing the required parameter `text` when calling `widget_text_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'backgroundcolor' in params:
            form_params.append(('backgroundcolor', params['backgroundcolor']))  # noqa: E501
        if 'marquee_inline_selector' in params:
            form_params.append(('marqueeInlineSelector', params['marquee_inline_selector']))  # noqa: E501
        if 'text' in params:
            form_params.append(('text', params['text']))  # noqa: E501
        if 'java_script' in params:
            form_params.append(('javaScript', params['java_script']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/text/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_ticker_add(self, playlist_id, source_id, uri, data_set_id, **kwargs):  # noqa: E501
        """Add a ticker Widget  # noqa: E501

        Add a new ticker Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_ticker_add(playlist_id, source_id, uri, data_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param int source_id: Add only - 1 for rss feed, 2 for dataset (required)
        :param str uri: For sourceId=1, the link for the rss feed (required)
        :param int data_set_id: For sourceId=2, Create ticker Widget using provided dataSetId of an existing dataSet (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int update_interval: EDIT Only - Update interval in minutes
        :param str effect: Edit only - Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind, marqueeUp, marqueeDown, marqueeRight, marqueeLeft
        :param int speed: Edit only - The transition speed of the selected effect in milliseconds (1000 = normal) or the Marquee speed in a low to high scale (normal = 1)
        :param str copyright: EDIT Only and SourceId=1 - Copyright information to display as the last item in this feed. can be styled with the #copyright CSS selector
        :param int num_items: EDIT Only and SourceId=1 - The number of RSS items you want to display
        :param str take_items_from: EDIT Only and SourceId=1 - Take the items form the beginning or the end of the list, available options: start, end
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per item, otherwise it is per feed
        :param int items_side_by_side: A flag (0, 1), Should items be shown side by side
        :param int upper_limit: EDIT Only, SourceId=2 - Upper low limit for this dataSet, 0 for nor limit
        :param int lower_limit: EDIT Only, SourceId=2 - Lower low limit for this dataSet, 0 for nor limit
        :param int items_per_page: EDIT Only - When in single mode, how many items per page should be shown
        :param str date_format: EDIT Only - The date format to apply to all dates returned by the ticker
        :param str allowed_attributes: EDIT Only and SourceId=1 - A comma separated list of attributes that should not be stripped from the feed
        :param str strip_tags: EDIT Only and SourceId=1 - A comma separated list of attributes that should be stripped from the feed
        :param str background_color: Edit only - A HEX color to use as the background color of this widget
        :param int disable_date_sort: EDIT Only, SourceId=1 - Should the date sort applied to the feed be disabled?
        :param str text_direction: EDIT Only, SourceId=1 - Which direction does the text in the feed use? Available options: ltr, rtl
        :param str no_data_message: EDIT Only - A message to display when no data is returned from the source
        :param str template_id: EDIT Only, SourceId=1 - Template you'd like to apply, options available: title-only, prominent-title-with-desc-and-name-separator, media-rss-with-title, media-rss-wth-left-hand-text, media-rss-image-only
        :param int override_template: EDIT Only, SourceId=1 - flag (0, 1) override template checkbox
        :param str template: Template for each item, replaces [itemsTemplate] in main template, Pass only with overrideTemplate set to 1 or with sourceId=2 
        :param str css: Optional StyleSheet Pass only with overrideTemplate set to 1 or with sourceId=2 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :param str filter: EDIT Only, SourceId=2 - SQL clause for filter this dataSet
        :param str ordering: EDIT Only, SourceId=2- SQL clause for how this dataSet should be ordered
        :param int use_ordering_clause: EDIT Only, SourceId=2 - flag (0,1) Use advanced order clause - set to 1 if ordering is provided
        :param int use_filtering_clause: EDIT Only, SourceId=2 - flag (0,1) Use advanced filter clause - set to 1 if filter is provided
        :param int randomise_items: A flag (0, 1), whether to randomise the feed
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_ticker_add_with_http_info(playlist_id, source_id, uri, data_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_ticker_add_with_http_info(playlist_id, source_id, uri, data_set_id, **kwargs)  # noqa: E501
            return data

    def widget_ticker_add_with_http_info(self, playlist_id, source_id, uri, data_set_id, **kwargs):  # noqa: E501
        """Add a ticker Widget  # noqa: E501

        Add a new ticker Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_ticker_add_with_http_info(playlist_id, source_id, uri, data_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param int source_id: Add only - 1 for rss feed, 2 for dataset (required)
        :param str uri: For sourceId=1, the link for the rss feed (required)
        :param int data_set_id: For sourceId=2, Create ticker Widget using provided dataSetId of an existing dataSet (required)
        :param str name: Optional Widget Name
        :param int duration: The Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int update_interval: EDIT Only - Update interval in minutes
        :param str effect: Edit only - Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind, marqueeUp, marqueeDown, marqueeRight, marqueeLeft
        :param int speed: Edit only - The transition speed of the selected effect in milliseconds (1000 = normal) or the Marquee speed in a low to high scale (normal = 1)
        :param str copyright: EDIT Only and SourceId=1 - Copyright information to display as the last item in this feed. can be styled with the #copyright CSS selector
        :param int num_items: EDIT Only and SourceId=1 - The number of RSS items you want to display
        :param str take_items_from: EDIT Only and SourceId=1 - Take the items form the beginning or the end of the list, available options: start, end
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per item, otherwise it is per feed
        :param int items_side_by_side: A flag (0, 1), Should items be shown side by side
        :param int upper_limit: EDIT Only, SourceId=2 - Upper low limit for this dataSet, 0 for nor limit
        :param int lower_limit: EDIT Only, SourceId=2 - Lower low limit for this dataSet, 0 for nor limit
        :param int items_per_page: EDIT Only - When in single mode, how many items per page should be shown
        :param str date_format: EDIT Only - The date format to apply to all dates returned by the ticker
        :param str allowed_attributes: EDIT Only and SourceId=1 - A comma separated list of attributes that should not be stripped from the feed
        :param str strip_tags: EDIT Only and SourceId=1 - A comma separated list of attributes that should be stripped from the feed
        :param str background_color: Edit only - A HEX color to use as the background color of this widget
        :param int disable_date_sort: EDIT Only, SourceId=1 - Should the date sort applied to the feed be disabled?
        :param str text_direction: EDIT Only, SourceId=1 - Which direction does the text in the feed use? Available options: ltr, rtl
        :param str no_data_message: EDIT Only - A message to display when no data is returned from the source
        :param str template_id: EDIT Only, SourceId=1 - Template you'd like to apply, options available: title-only, prominent-title-with-desc-and-name-separator, media-rss-with-title, media-rss-wth-left-hand-text, media-rss-image-only
        :param int override_template: EDIT Only, SourceId=1 - flag (0, 1) override template checkbox
        :param str template: Template for each item, replaces [itemsTemplate] in main template, Pass only with overrideTemplate set to 1 or with sourceId=2 
        :param str css: Optional StyleSheet Pass only with overrideTemplate set to 1 or with sourceId=2 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :param str filter: EDIT Only, SourceId=2 - SQL clause for filter this dataSet
        :param str ordering: EDIT Only, SourceId=2- SQL clause for how this dataSet should be ordered
        :param int use_ordering_clause: EDIT Only, SourceId=2 - flag (0,1) Use advanced order clause - set to 1 if ordering is provided
        :param int use_filtering_clause: EDIT Only, SourceId=2 - flag (0,1) Use advanced filter clause - set to 1 if filter is provided
        :param int randomise_items: A flag (0, 1), whether to randomise the feed
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'source_id', 'uri', 'data_set_id', 'name', 'duration', 'use_duration', 'update_interval', 'effect', 'speed', 'copyright', 'num_items', 'take_items_from', 'duration_is_per_item', 'items_side_by_side', 'upper_limit', 'lower_limit', 'items_per_page', 'date_format', 'allowed_attributes', 'strip_tags', 'background_color', 'disable_date_sort', 'text_direction', 'no_data_message', 'template_id', 'override_template', 'template', 'css', 'java_script', 'filter', 'ordering', 'use_ordering_clause', 'use_filtering_clause', 'randomise_items']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_ticker_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_ticker_add`")  # noqa: E501
        # verify the required parameter 'source_id' is set
        if ('source_id' not in params or
                params['source_id'] is None):
            raise ValueError("Missing the required parameter `source_id` when calling `widget_ticker_add`")  # noqa: E501
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `widget_ticker_add`")  # noqa: E501
        # verify the required parameter 'data_set_id' is set
        if ('data_set_id' not in params or
                params['data_set_id'] is None):
            raise ValueError("Missing the required parameter `data_set_id` when calling `widget_ticker_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'source_id' in params:
            form_params.append(('sourceId', params['source_id']))  # noqa: E501
        if 'uri' in params:
            form_params.append(('uri', params['uri']))  # noqa: E501
        if 'data_set_id' in params:
            form_params.append(('dataSetId', params['data_set_id']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'copyright' in params:
            form_params.append(('copyright', params['copyright']))  # noqa: E501
        if 'num_items' in params:
            form_params.append(('numItems', params['num_items']))  # noqa: E501
        if 'take_items_from' in params:
            form_params.append(('takeItemsFrom', params['take_items_from']))  # noqa: E501
        if 'duration_is_per_item' in params:
            form_params.append(('durationIsPerItem', params['duration_is_per_item']))  # noqa: E501
        if 'items_side_by_side' in params:
            form_params.append(('itemsSideBySide', params['items_side_by_side']))  # noqa: E501
        if 'upper_limit' in params:
            form_params.append(('upperLimit', params['upper_limit']))  # noqa: E501
        if 'lower_limit' in params:
            form_params.append(('lowerLimit', params['lower_limit']))  # noqa: E501
        if 'items_per_page' in params:
            form_params.append(('itemsPerPage', params['items_per_page']))  # noqa: E501
        if 'date_format' in params:
            form_params.append(('dateFormat', params['date_format']))  # noqa: E501
        if 'allowed_attributes' in params:
            form_params.append(('allowedAttributes', params['allowed_attributes']))  # noqa: E501
        if 'strip_tags' in params:
            form_params.append(('stripTags', params['strip_tags']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'disable_date_sort' in params:
            form_params.append(('disableDateSort', params['disable_date_sort']))  # noqa: E501
        if 'text_direction' in params:
            form_params.append(('textDirection', params['text_direction']))  # noqa: E501
        if 'no_data_message' in params:
            form_params.append(('noDataMessage', params['no_data_message']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501
        if 'css' in params:
            form_params.append(('css', params['css']))  # noqa: E501
        if 'java_script' in params:
            form_params.append(('javaScript', params['java_script']))  # noqa: E501
        if 'filter' in params:
            form_params.append(('filter', params['filter']))  # noqa: E501
        if 'ordering' in params:
            form_params.append(('ordering', params['ordering']))  # noqa: E501
        if 'use_ordering_clause' in params:
            form_params.append(('useOrderingClause', params['use_ordering_clause']))  # noqa: E501
        if 'use_filtering_clause' in params:
            form_params.append(('useFilteringClause', params['use_filtering_clause']))  # noqa: E501
        if 'randomise_items' in params:
            form_params.append(('randomiseItems', params['randomise_items']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/ticker/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_twitter_add(self, playlist_id, search_term, **kwargs):  # noqa: E501
        """Add a Twitter Widget  # noqa: E501

        Add a new Twitter Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_twitter_add(playlist_id, search_term, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Twitter widget (required)
        :param str search_term: Twitter search term, you can test your search term in twitter.com search box first (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str language: Language in which tweets should be returned
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_tweets_message: A message to display when there are no tweets returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param str result_type: 1 - Mixed, 2 -Recent 3 - Popular, Recent shows only recent tweets, Popular the most popular tweets and Mixed included both popular and recent
        :param int tweet_distance: Distance in miles that the tweets should be returned from. Set 0 for no restrictions
        :param int tweet_count: The number of tweets to return
        :param int remove_urls: Flag (0, 1) Should the URLs be removed from the tweet text?
        :param int remove_mentions: Flag (0, 1) Should mentions (@someone) be removed from the tweet text?
        :param int remove_hashtags: Flag (0, 1) Should the hashtags (#something) be removed from the tweet text
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per page/item, otherwise the widget duration is divided between the number of pages/items
        :param int items_per_page: EDIT Only - When in single mode, how many items per page should be shown
        :param str template_id: Use pre-configured templates, available options: full-timeline-np, full-timeline, tweet-only, tweet-with-profileimage-left, tweet-with-profileimage-right, tweet-1, tweet-2, tweet-4. tweet-6NP, tweet-6PL, tweet-7, tweet-8
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int widget_original_width: This is the intended Width of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_height: This is the intended Height of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_padding: This is the intended Padding of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param str result_content: Intended content Type, available Options: 0 - All Tweets 1 - Tweets with the text only content 2 - Tweets with the text and image content. Pass only with overrideTemplate set to 1
        :param str template: Main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_twitter_add_with_http_info(playlist_id, search_term, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_twitter_add_with_http_info(playlist_id, search_term, **kwargs)  # noqa: E501
            return data

    def widget_twitter_add_with_http_info(self, playlist_id, search_term, **kwargs):  # noqa: E501
        """Add a Twitter Widget  # noqa: E501

        Add a new Twitter Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_twitter_add_with_http_info(playlist_id, search_term, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Twitter widget (required)
        :param str search_term: Twitter search term, you can test your search term in twitter.com search box first (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str language: Language in which tweets should be returned
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_tweets_message: A message to display when there are no tweets returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param str result_type: 1 - Mixed, 2 -Recent 3 - Popular, Recent shows only recent tweets, Popular the most popular tweets and Mixed included both popular and recent
        :param int tweet_distance: Distance in miles that the tweets should be returned from. Set 0 for no restrictions
        :param int tweet_count: The number of tweets to return
        :param int remove_urls: Flag (0, 1) Should the URLs be removed from the tweet text?
        :param int remove_mentions: Flag (0, 1) Should mentions (@someone) be removed from the tweet text?
        :param int remove_hashtags: Flag (0, 1) Should the hashtags (#something) be removed from the tweet text
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param int duration_is_per_item: A flag (0, 1), The duration specified is per page/item, otherwise the widget duration is divided between the number of pages/items
        :param int items_per_page: EDIT Only - When in single mode, how many items per page should be shown
        :param str template_id: Use pre-configured templates, available options: full-timeline-np, full-timeline, tweet-only, tweet-with-profileimage-left, tweet-with-profileimage-right, tweet-1, tweet-2, tweet-4. tweet-6NP, tweet-6PL, tweet-7, tweet-8
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int widget_original_width: This is the intended Width of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_height: This is the intended Height of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_padding: This is the intended Padding of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param str result_content: Intended content Type, available Options: 0 - All Tweets 1 - Tweets with the text only content 2 - Tweets with the text and image content. Pass only with overrideTemplate set to 1
        :param str template: Main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet Pass only with overrideTemplate set to 1 
        :param str java_script: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'search_term', 'name', 'duration', 'use_duration', 'language', 'effect', 'speed', 'background_color', 'no_tweets_message', 'date_format', 'result_type', 'tweet_distance', 'tweet_count', 'remove_urls', 'remove_mentions', 'remove_hashtags', 'update_interval', 'duration_is_per_item', 'items_per_page', 'template_id', 'override_template', 'widget_original_width', 'widget_original_height', 'widget_original_padding', 'result_content', 'template', 'style_sheet', 'java_script']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_twitter_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_twitter_add`")  # noqa: E501
        # verify the required parameter 'search_term' is set
        if ('search_term' not in params or
                params['search_term'] is None):
            raise ValueError("Missing the required parameter `search_term` when calling `widget_twitter_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'search_term' in params:
            form_params.append(('searchTerm', params['search_term']))  # noqa: E501
        if 'language' in params:
            form_params.append(('language', params['language']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'no_tweets_message' in params:
            form_params.append(('noTweetsMessage', params['no_tweets_message']))  # noqa: E501
        if 'date_format' in params:
            form_params.append(('dateFormat', params['date_format']))  # noqa: E501
        if 'result_type' in params:
            form_params.append(('resultType', params['result_type']))  # noqa: E501
        if 'tweet_distance' in params:
            form_params.append(('tweetDistance', params['tweet_distance']))  # noqa: E501
        if 'tweet_count' in params:
            form_params.append(('tweetCount', params['tweet_count']))  # noqa: E501
        if 'remove_urls' in params:
            form_params.append(('removeUrls', params['remove_urls']))  # noqa: E501
        if 'remove_mentions' in params:
            form_params.append(('removeMentions', params['remove_mentions']))  # noqa: E501
        if 'remove_hashtags' in params:
            form_params.append(('removeHashtags', params['remove_hashtags']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'duration_is_per_item' in params:
            form_params.append(('durationIsPerItem', params['duration_is_per_item']))  # noqa: E501
        if 'items_per_page' in params:
            form_params.append(('itemsPerPage', params['items_per_page']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'widget_original_width' in params:
            form_params.append(('widgetOriginalWidth', params['widget_original_width']))  # noqa: E501
        if 'widget_original_height' in params:
            form_params.append(('widgetOriginalHeight', params['widget_original_height']))  # noqa: E501
        if 'widget_original_padding' in params:
            form_params.append(('widgetOriginalPadding', params['widget_original_padding']))  # noqa: E501
        if 'result_content' in params:
            form_params.append(('resultContent', params['result_content']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501
        if 'style_sheet' in params:
            form_params.append(('styleSheet', params['style_sheet']))  # noqa: E501
        if 'java_script' in params:
            form_params.append(('javaScript', params['java_script']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/twitter/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_twitter_metro_add(self, playlist_id, search_term, **kwargs):  # noqa: E501
        """Add a Twitter Metro Widget  # noqa: E501

        Add a new Twitter Metro Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_twitter_metro_add(playlist_id, search_term, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Twitter Metro widget (required)
        :param str search_term: Twitter search term, you can test your search term in twitter.com search box first (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str language: Language in which tweets should be returned
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_tweets_message: A message to display when there are no tweets returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param str result_type: 1 - Mixed, 2 -Recent 3 - Popular, Recent shows only recent tweets, Popular the most popular tweets and Mixed included both popular and recent
        :param int tweet_distance: Distance in miles that the tweets should be returned from. Set 0 for no restrictions
        :param int tweet_count: The number of tweets to return
        :param int remove_urls: Flag (0, 1) Should the URLs be removed from the tweet text?
        :param int remove_mentions: Flag (0, 1) Should mentions (@someone) be removed from the tweet text?
        :param int remove_hashtags: Flag (0, 1) Should the hashtags (#something) be removed from the tweet text
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str color_template_id: Use pre-configured templates, available options: default, full, gray, light, soft, vivid
        :param int override_color_template: flag (0, 1) set to 0 and use colorTemplateId or set to 1 and provide colours to use in templateColours parameter
        :param str template_colours: Provide a string of new HEX colour codes to use, separated by |, for example: #e0d2c8|#5e411d|#fccf12|#82ff00|#64bae8
        :param str result_content: Intended content Type, available Options: 0 - All Tweets 1 - Tweets with the text only content 2 - Tweets with the text and image content. Pass only with overrideColorTemplate set to 1
        :param int remove_retweets: Flag (0, 1) Should retweets be filtered?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_twitter_metro_add_with_http_info(playlist_id, search_term, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_twitter_metro_add_with_http_info(playlist_id, search_term, **kwargs)  # noqa: E501
            return data

    def widget_twitter_metro_add_with_http_info(self, playlist_id, search_term, **kwargs):  # noqa: E501
        """Add a Twitter Metro Widget  # noqa: E501

        Add a new Twitter Metro Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_twitter_metro_add_with_http_info(playlist_id, search_term, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Twitter Metro widget (required)
        :param str search_term: Twitter search term, you can test your search term in twitter.com search box first (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param str language: Language in which tweets should be returned
        :param str effect: Effect that will be used to transitions between items, available options: fade, fadeout, scrollVert, scollHorz, flipVert, flipHorz, shuffle, tileSlide, tileBlind 
        :param int speed: The transition speed of the selected effect in milliseconds (1000 = normal)
        :param str background_color: A HEX color to use as the background color of this widget
        :param str no_tweets_message: A message to display when there are no tweets returned by the search query
        :param str date_format: The format to apply to all dates returned by he widget
        :param str result_type: 1 - Mixed, 2 -Recent 3 - Popular, Recent shows only recent tweets, Popular the most popular tweets and Mixed included both popular and recent
        :param int tweet_distance: Distance in miles that the tweets should be returned from. Set 0 for no restrictions
        :param int tweet_count: The number of tweets to return
        :param int remove_urls: Flag (0, 1) Should the URLs be removed from the tweet text?
        :param int remove_mentions: Flag (0, 1) Should mentions (@someone) be removed from the tweet text?
        :param int remove_hashtags: Flag (0, 1) Should the hashtags (#something) be removed from the tweet text
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str color_template_id: Use pre-configured templates, available options: default, full, gray, light, soft, vivid
        :param int override_color_template: flag (0, 1) set to 0 and use colorTemplateId or set to 1 and provide colours to use in templateColours parameter
        :param str template_colours: Provide a string of new HEX colour codes to use, separated by |, for example: #e0d2c8|#5e411d|#fccf12|#82ff00|#64bae8
        :param str result_content: Intended content Type, available Options: 0 - All Tweets 1 - Tweets with the text only content 2 - Tweets with the text and image content. Pass only with overrideColorTemplate set to 1
        :param int remove_retweets: Flag (0, 1) Should retweets be filtered?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'search_term', 'name', 'duration', 'use_duration', 'language', 'effect', 'speed', 'background_color', 'no_tweets_message', 'date_format', 'result_type', 'tweet_distance', 'tweet_count', 'remove_urls', 'remove_mentions', 'remove_hashtags', 'update_interval', 'color_template_id', 'override_color_template', 'template_colours', 'result_content', 'remove_retweets']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_twitter_metro_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_twitter_metro_add`")  # noqa: E501
        # verify the required parameter 'search_term' is set
        if ('search_term' not in params or
                params['search_term'] is None):
            raise ValueError("Missing the required parameter `search_term` when calling `widget_twitter_metro_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'search_term' in params:
            form_params.append(('searchTerm', params['search_term']))  # noqa: E501
        if 'language' in params:
            form_params.append(('language', params['language']))  # noqa: E501
        if 'effect' in params:
            form_params.append(('effect', params['effect']))  # noqa: E501
        if 'speed' in params:
            form_params.append(('speed', params['speed']))  # noqa: E501
        if 'background_color' in params:
            form_params.append(('backgroundColor', params['background_color']))  # noqa: E501
        if 'no_tweets_message' in params:
            form_params.append(('noTweetsMessage', params['no_tweets_message']))  # noqa: E501
        if 'date_format' in params:
            form_params.append(('dateFormat', params['date_format']))  # noqa: E501
        if 'result_type' in params:
            form_params.append(('resultType', params['result_type']))  # noqa: E501
        if 'tweet_distance' in params:
            form_params.append(('tweetDistance', params['tweet_distance']))  # noqa: E501
        if 'tweet_count' in params:
            form_params.append(('tweetCount', params['tweet_count']))  # noqa: E501
        if 'remove_urls' in params:
            form_params.append(('removeUrls', params['remove_urls']))  # noqa: E501
        if 'remove_mentions' in params:
            form_params.append(('removeMentions', params['remove_mentions']))  # noqa: E501
        if 'remove_hashtags' in params:
            form_params.append(('removeHashtags', params['remove_hashtags']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'color_template_id' in params:
            form_params.append(('colorTemplateId', params['color_template_id']))  # noqa: E501
        if 'override_color_template' in params:
            form_params.append(('overrideColorTemplate', params['override_color_template']))  # noqa: E501
        if 'template_colours' in params:
            form_params.append(('templateColours', params['template_colours']))  # noqa: E501
        if 'result_content' in params:
            form_params.append(('resultContent', params['result_content']))  # noqa: E501
        if 'remove_retweets' in params:
            form_params.append(('removeRetweets', params['remove_retweets']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/twittermetro/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_video_edit(self, **kwargs):  # noqa: E501
        """Parameters for editing existing video on a layout  # noqa: E501

        Parameters for editing existing video on a layout, for adding new videos, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_video_edit(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Edit only - Optional Widget Name
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int duration: Edit Only - The Widget Duration
        :param str scale_type_id: How should the video be scaled, available options: aspect, stretch
        :param int mute: Edit only - Flag (0, 1) Should the video be muted?
        :param int loop: Edit only - Flag (0, 1) Should the video loop (only for duration > 0 )?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_video_edit_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.widget_video_edit_with_http_info(**kwargs)  # noqa: E501
            return data

    def widget_video_edit_with_http_info(self, **kwargs):  # noqa: E501
        """Parameters for editing existing video on a layout  # noqa: E501

        Parameters for editing existing video on a layout, for adding new videos, please refer to POST /library documentation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_video_edit_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Edit only - Optional Widget Name
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int duration: Edit Only - The Widget Duration
        :param str scale_type_id: How should the video be scaled, available options: aspect, stretch
        :param int mute: Edit only - Flag (0, 1) Should the video be muted?
        :param int loop: Edit only - Flag (0, 1) Should the video loop (only for duration > 0 )?
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'use_duration', 'duration', 'scale_type_id', 'mute', 'loop']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_video_edit" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'scale_type_id' in params:
            form_params.append(('scaleTypeId', params['scale_type_id']))  # noqa: E501
        if 'mute' in params:
            form_params.append(('mute', params['mute']))  # noqa: E501
        if 'loop' in params:
            form_params.append(('loop', params['loop']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/video/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_video_in_add(self, playlist_id, source_id, **kwargs):  # noqa: E501
        """Add a Video In Widget  # noqa: E501

        Add a new Video In Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_video_in_add(playlist_id, source_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str source_id: Which device input should be shown? available options: HDMI, RGB, DVI, DP, OPS (required)
        :param int duration: The Widget Duration
        :param int use_duration: Flag (0, 1) Select only if you will provide duration parameter as well
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_video_in_add_with_http_info(playlist_id, source_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_video_in_add_with_http_info(playlist_id, source_id, **kwargs)  # noqa: E501
            return data

    def widget_video_in_add_with_http_info(self, playlist_id, source_id, **kwargs):  # noqa: E501
        """Add a Video In Widget  # noqa: E501

        Add a new Video In Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_video_in_add_with_http_info(playlist_id, source_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param str source_id: Which device input should be shown? available options: HDMI, RGB, DVI, DP, OPS (required)
        :param int duration: The Widget Duration
        :param int use_duration: Flag (0, 1) Select only if you will provide duration parameter as well
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'source_id', 'duration', 'use_duration']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_video_in_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_video_in_add`")  # noqa: E501
        # verify the required parameter 'source_id' is set
        if ('source_id' not in params or
                params['source_id'] is None):
            raise ValueError("Missing the required parameter `source_id` when calling `widget_video_in_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'source_id' in params:
            form_params.append(('sourceId', params['source_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/videoin/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_weather_add(self, playlist_id, use_display_location, **kwargs):  # noqa: E501
        """Add a Weather Widget  # noqa: E501

        Add a new Weather Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_weather_add(playlist_id, use_display_location, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Weather widget (required)
        :param int use_display_location: Flag (0, 1) Use the location configured on display (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param float longitude: The longitude for this weather widget, only pass if useDisplayLocation set to 0
        :param float latitude: The latitude for this weather widget, only pass if useDisplayLocation set to 0
        :param str template_id: Use pre-configured templates, available options: weather-module0-5day, weather-module0-singleday, weather-module0-singleday2, weather-module1l, weather-module1p, weather-module2l, weather-module2p, weather-module3l, weather-module3p, weather-module4l, weather-module4p, weather-module5l, weather-module6v, weather-module6h
        :param str units: Units you would like to use, available options: auto, ca, si, uk2, us
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str lang: Language you'd like to use, supported languages ar, az, be, bs, cs, de, en, el, es, fr, hr, hu, id, it, is, kw, nb, nl, pl, pt, ru, sk, sr, sv, tet, tr, uk, x-pig-latin, zh, zh-tw
        :param int day_conditions_only: Flag (0, 1) Would you like to only show the Daytime weather conditions
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int widget_original_width: This is the intended Width of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_height: This is the intended Height of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param str current_template: Current template, Pass only with overrideTemplate set to 1 
        :param str daily_template: Replaces [dailyForecast] in main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet, Pass only with overrideTemplate set to 1 
        :param str style_sheet2: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_weather_add_with_http_info(playlist_id, use_display_location, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_weather_add_with_http_info(playlist_id, use_display_location, **kwargs)  # noqa: E501
            return data

    def widget_weather_add_with_http_info(self, playlist_id, use_display_location, **kwargs):  # noqa: E501
        """Add a Weather Widget  # noqa: E501

        Add a new Weather Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_weather_add_with_http_info(playlist_id, use_display_location, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Weather widget (required)
        :param int use_display_location: Flag (0, 1) Use the location configured on display (required)
        :param str name: Optional Widget Name
        :param int duration: Widget Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param float longitude: The longitude for this weather widget, only pass if useDisplayLocation set to 0
        :param float latitude: The latitude for this weather widget, only pass if useDisplayLocation set to 0
        :param str template_id: Use pre-configured templates, available options: weather-module0-5day, weather-module0-singleday, weather-module0-singleday2, weather-module1l, weather-module1p, weather-module2l, weather-module2p, weather-module3l, weather-module3p, weather-module4l, weather-module4p, weather-module5l, weather-module6v, weather-module6h
        :param str units: Units you would like to use, available options: auto, ca, si, uk2, us
        :param int update_interval: Update interval in minutes, should be kept as high as possible, if data change once per hour, this should be set to 60
        :param str lang: Language you'd like to use, supported languages ar, az, be, bs, cs, de, en, el, es, fr, hr, hu, id, it, is, kw, nb, nl, pl, pt, ru, sk, sr, sv, tet, tr, uk, x-pig-latin, zh, zh-tw
        :param int day_conditions_only: Flag (0, 1) Would you like to only show the Daytime weather conditions
        :param int override_template: flag (0, 1) set to 0 and use templateId or set to 1 and provide whole template in the next parameters
        :param int widget_original_width: This is the intended Width of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param int widget_original_height: This is the intended Height of the template and is used to scale the Widget within it's region when the template is applied, Pass only with overrideTemplate set to 1
        :param str current_template: Current template, Pass only with overrideTemplate set to 1 
        :param str daily_template: Replaces [dailyForecast] in main template, Pass only with overrideTemplate set to 1 
        :param str style_sheet: Optional StyleSheet, Pass only with overrideTemplate set to 1 
        :param str style_sheet2: Optional JavaScript, Pass only with overrideTemplate set to 1 
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'use_display_location', 'name', 'duration', 'use_duration', 'longitude', 'latitude', 'template_id', 'units', 'update_interval', 'lang', 'day_conditions_only', 'override_template', 'widget_original_width', 'widget_original_height', 'current_template', 'daily_template', 'style_sheet', 'style_sheet2']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_weather_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_weather_add`")  # noqa: E501
        # verify the required parameter 'use_display_location' is set
        if ('use_display_location' not in params or
                params['use_display_location'] is None):
            raise ValueError("Missing the required parameter `use_display_location` when calling `widget_weather_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'use_display_location' in params:
            form_params.append(('useDisplayLocation', params['use_display_location']))  # noqa: E501
        if 'longitude' in params:
            form_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'latitude' in params:
            form_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'units' in params:
            form_params.append(('units', params['units']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'lang' in params:
            form_params.append(('lang', params['lang']))  # noqa: E501
        if 'day_conditions_only' in params:
            form_params.append(('dayConditionsOnly', params['day_conditions_only']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'widget_original_width' in params:
            form_params.append(('widgetOriginalWidth', params['widget_original_width']))  # noqa: E501
        if 'widget_original_height' in params:
            form_params.append(('widgetOriginalHeight', params['widget_original_height']))  # noqa: E501
        if 'current_template' in params:
            form_params.append(('currentTemplate', params['current_template']))  # noqa: E501
        if 'daily_template' in params:
            form_params.append(('dailyTemplate', params['daily_template']))  # noqa: E501
        if 'style_sheet' in params:
            form_params.append(('styleSheet', params['style_sheet']))  # noqa: E501
        if 'style_sheet2' in params:
            form_params.append(('styleSheet', params['style_sheet2']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/forecastIo/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widget_webpage_add(self, playlist_id, uri, mode_id, **kwargs):  # noqa: E501
        """Add a Web page Widget  # noqa: E501

        Add a new Web page Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_webpage_add(playlist_id, uri, mode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Web page to (required)
        :param str uri:  string containing the location (URL) of the web page (required)
        :param int mode_id: The mode option for Web page, 1- Open Natively, 2- Manual Position, 3- Best Ft (required)
        :param str name: Optional Widget Name
        :param int duration: The Web page Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int transparency:  flag (0,1) should the HTML be shown with a transparent background?
        :param int scaling: For Manual position the percentage to scale the Web page (0-100)
        :param int offset_left: For Manual position, the starting point from the left in pixels
        :param int offset_top: For Manual position, the starting point from the Top in pixels
        :param int page_width: For Manual Position and Best Fit, The width of the page - if empty it will use region width
        :param int page_height: For Manual Position and Best Fit, The height of the page - if empty it will use region height
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widget_webpage_add_with_http_info(playlist_id, uri, mode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widget_webpage_add_with_http_info(playlist_id, uri, mode_id, **kwargs)  # noqa: E501
            return data

    def widget_webpage_add_with_http_info(self, playlist_id, uri, mode_id, **kwargs):  # noqa: E501
        """Add a Web page Widget  # noqa: E501

        Add a new Web page Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widget_webpage_add_with_http_info(playlist_id, uri, mode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Web page to (required)
        :param str uri:  string containing the location (URL) of the web page (required)
        :param int mode_id: The mode option for Web page, 1- Open Natively, 2- Manual Position, 3- Best Ft (required)
        :param str name: Optional Widget Name
        :param int duration: The Web page Duration
        :param int use_duration: (0, 1) Select 1 only if you will provide duration parameter as well
        :param int transparency:  flag (0,1) should the HTML be shown with a transparent background?
        :param int scaling: For Manual position the percentage to scale the Web page (0-100)
        :param int offset_left: For Manual position, the starting point from the left in pixels
        :param int offset_top: For Manual position, the starting point from the Top in pixels
        :param int page_width: For Manual Position and Best Fit, The width of the page - if empty it will use region width
        :param int page_height: For Manual Position and Best Fit, The height of the page - if empty it will use region height
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'uri', 'mode_id', 'name', 'duration', 'use_duration', 'transparency', 'scaling', 'offset_left', 'offset_top', 'page_width', 'page_height']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widget_webpage_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widget_webpage_add`")  # noqa: E501
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `widget_webpage_add`")  # noqa: E501
        # verify the required parameter 'mode_id' is set
        if ('mode_id' not in params or
                params['mode_id'] is None):
            raise ValueError("Missing the required parameter `mode_id` when calling `widget_webpage_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'transparency' in params:
            form_params.append(('transparency', params['transparency']))  # noqa: E501
        if 'uri' in params:
            form_params.append(('uri', params['uri']))  # noqa: E501
        if 'scaling' in params:
            form_params.append(('scaling', params['scaling']))  # noqa: E501
        if 'offset_left' in params:
            form_params.append(('offsetLeft', params['offset_left']))  # noqa: E501
        if 'offset_top' in params:
            form_params.append(('offsetTop', params['offset_top']))  # noqa: E501
        if 'page_width' in params:
            form_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            form_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'mode_id' in params:
            form_params.append(('modeId', params['mode_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/webpage/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def widgetdata_set_view_add(self, playlist_id, data_set_id, **kwargs):  # noqa: E501
        """Add a dataSetView Widget  # noqa: E501

        Add a new dataSetView Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widgetdata_set_view_add(playlist_id, data_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param int data_set_id: Create dataSetView Widget using provided dataSetId of an existing dataSet (required)
        :param str name: Optional Widget Name
        :param list[int] data_set_column_id:  EDIT only - Array of dataSetColumn IDs to assign
        :param int duration: EDIT Only - The dataSetView Duration
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int update_interval: EDIT Only - Update interval in minutes
        :param int rows_per_page: EDIT Only - Number of rows per page, 0 for no pages
        :param int show_headings: EDIT Only - Should the table show Heading? (0,1)
        :param int upper_limit: EDIT Only - Upper low limit for this dataSet, 0 for nor limit
        :param int lower_limit: EDIT Only - Lower low limit for this dataSet, 0 for nor limit
        :param str filter: EDIT Only - SQL clause for filter this dataSet
        :param str ordering: EDIT Only - SQL clause for how this dataSet should be ordered
        :param str template_id: EDIT Only - Template you'd like to apply, options available: empty, light-green
        :param int override_template: EDIT Only - flag (0, 1) override template checkbox
        :param int use_ordering_clause: EDIT Only - flag (0,1) Use advanced order clause - set to 1 if ordering is provided
        :param int use_filtering_clause: EDIT Only - flag (0,1) Use advanced filter clause - set to 1 if filter is provided
        :param str no_data_message: EDIT Only - A message to display when no data is returned from the source
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.widgetdata_set_view_add_with_http_info(playlist_id, data_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.widgetdata_set_view_add_with_http_info(playlist_id, data_set_id, **kwargs)  # noqa: E501
            return data

    def widgetdata_set_view_add_with_http_info(self, playlist_id, data_set_id, **kwargs):  # noqa: E501
        """Add a dataSetView Widget  # noqa: E501

        Add a new dataSetView Widget to the specified playlist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.widgetdata_set_view_add_with_http_info(playlist_id, data_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int playlist_id: The playlist ID to add a Widget to (required)
        :param int data_set_id: Create dataSetView Widget using provided dataSetId of an existing dataSet (required)
        :param str name: Optional Widget Name
        :param list[int] data_set_column_id:  EDIT only - Array of dataSetColumn IDs to assign
        :param int duration: EDIT Only - The dataSetView Duration
        :param int use_duration: Edit Only - (0, 1) Select 1 only if you will provide duration parameter as well
        :param int update_interval: EDIT Only - Update interval in minutes
        :param int rows_per_page: EDIT Only - Number of rows per page, 0 for no pages
        :param int show_headings: EDIT Only - Should the table show Heading? (0,1)
        :param int upper_limit: EDIT Only - Upper low limit for this dataSet, 0 for nor limit
        :param int lower_limit: EDIT Only - Lower low limit for this dataSet, 0 for nor limit
        :param str filter: EDIT Only - SQL clause for filter this dataSet
        :param str ordering: EDIT Only - SQL clause for how this dataSet should be ordered
        :param str template_id: EDIT Only - Template you'd like to apply, options available: empty, light-green
        :param int override_template: EDIT Only - flag (0, 1) override template checkbox
        :param int use_ordering_clause: EDIT Only - flag (0,1) Use advanced order clause - set to 1 if ordering is provided
        :param int use_filtering_clause: EDIT Only - flag (0,1) Use advanced filter clause - set to 1 if filter is provided
        :param str no_data_message: EDIT Only - A message to display when no data is returned from the source
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['playlist_id', 'data_set_id', 'name', 'data_set_column_id', 'duration', 'use_duration', 'update_interval', 'rows_per_page', 'show_headings', 'upper_limit', 'lower_limit', 'filter', 'ordering', 'template_id', 'override_template', 'use_ordering_clause', 'use_filtering_clause', 'no_data_message']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method widgetdata_set_view_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'playlist_id' is set
        if ('playlist_id' not in params or
                params['playlist_id'] is None):
            raise ValueError("Missing the required parameter `playlist_id` when calling `widgetdata_set_view_add`")  # noqa: E501
        # verify the required parameter 'data_set_id' is set
        if ('data_set_id' not in params or
                params['data_set_id'] is None):
            raise ValueError("Missing the required parameter `data_set_id` when calling `widgetdata_set_view_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'playlist_id' in params:
            path_params['playlistId'] = params['playlist_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'data_set_id' in params:
            form_params.append(('dataSetId', params['data_set_id']))  # noqa: E501
        if 'data_set_column_id' in params:
            form_params.append(('dataSetColumnId', params['data_set_column_id']))  # noqa: E501
            collection_formats['dataSetColumnId'] = 'csv'  # noqa: E501
        if 'duration' in params:
            form_params.append(('duration', params['duration']))  # noqa: E501
        if 'use_duration' in params:
            form_params.append(('useDuration', params['use_duration']))  # noqa: E501
        if 'update_interval' in params:
            form_params.append(('updateInterval', params['update_interval']))  # noqa: E501
        if 'rows_per_page' in params:
            form_params.append(('rowsPerPage', params['rows_per_page']))  # noqa: E501
        if 'show_headings' in params:
            form_params.append(('showHeadings', params['show_headings']))  # noqa: E501
        if 'upper_limit' in params:
            form_params.append(('upperLimit', params['upper_limit']))  # noqa: E501
        if 'lower_limit' in params:
            form_params.append(('lowerLimit', params['lower_limit']))  # noqa: E501
        if 'filter' in params:
            form_params.append(('filter', params['filter']))  # noqa: E501
        if 'ordering' in params:
            form_params.append(('ordering', params['ordering']))  # noqa: E501
        if 'template_id' in params:
            form_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'override_template' in params:
            form_params.append(('overrideTemplate', params['override_template']))  # noqa: E501
        if 'use_ordering_clause' in params:
            form_params.append(('useOrderingClause', params['use_ordering_clause']))  # noqa: E501
        if 'use_filtering_clause' in params:
            form_params.append(('useFilteringClause', params['use_filtering_clause']))  # noqa: E501
        if 'no_data_message' in params:
            form_params.append(('noDataMessage', params['no_data_message']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['auth']  # noqa: E501

        return self.api_client.call_api(
            '/playlist/widget/dataSetView/{playlistId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Widget',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
